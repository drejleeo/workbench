bad_coffee_hex = 50159747054
SECRET = 'i23;2:QF()FA~@'
code = 5238923102
name = 'Asa Spades'
names_for_ids = {
    523: 'Bobby',
    923: 'Keanu',
    814: 'Shelby',
}


def first_method():
    '''String formatting operator - interpolation operator
    Usually used in python < 2.6.
    There are multiple formats specifiers available.
    Not in best practices anymore,
    but you might bump into it from time to time.
    %-formatting is going to stick around for a long time to come.'''

    yield 'Hello, %s' % name
    yield '%x' % code

    yield 'Hello %s, this is your code 0x%x!' % (name, code)
    # or
    yield 'Hello %(name)s, this is your code 0x%(code)x!' % {
        'name': name,
        'code': code
    }


def second_method():
    '''String formatting with the .format() method.
    This method is newer, preferred over %-style'''
    yield 'Hello {}, this is {}'.format(name, bad_coffee_hex)
    # or
    yield 'Hello {name}, this is {code}'.format(name=name, code=bad_coffee_hex)


def third_method():
    '''String Interpolation / f-Strings (Python 3.6+)
    Behind the scenes, the f-string in function gets
    transformed to something like this:

        yield 'Hello,' + name + ', this is your ' + code.

    The real implementation is slightly faster than that
    because it uses the BUILD_STRING opcode as an optimization.
    But functionally they’re the same:

    Python’s new formatted string literals are SIMILAR to
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~~~ JavaScript’s Template Literals added in ES2015 ~~~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This new way lets you use embedded Python expressions
    inside string constants, like below:'''

    yield f'Hello, {name}, this is your {code}.'
    a = 5; b = 23
    yield f'a + b equals {a + b} and a - b equals {a - b}'


def fourth_method():
    '''With Template Strings. Simple and ideal when
    dealing with data generated by the user

    It’s a simpler and LESS POWERFUL mechanism,
    but in some cases useful

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~IMPORTANT~~~~~~~~~~~~~~~~~~~~~~~~~~~
    So when should you use template strings in your Python programs?
    In my opinion, the best time to use template strings is when you’re
    handling formatted strings generated by users of your program.
    Due to their reduced complexity, template strings are a safer choice.

    The more complex formatting mini-languages of the other string
    formatting techniques might introduce security vulnerabilities to
    your programs. For example, it’s possible for format strings
    to access arbitrary variables in your program.

    That means, if a malicious user can supply a format string, they
    can potentially leak secret keys and other sensitive information!
    Here’s a simple proof of concept of how this attack might be used
    against your code:'''

    from string import Template
    _ = 'Hey, $name, but.. U SHALL NOT $verb!!'
    yield Template(_).substitute(name='haracalambua', verb='PASS')


    '''Example for the malicious input'''

    user_input = '{error.__init__.__globals__[SECRET]}'

    class Error:
        def __init__(self):
            pass
    err = Error()

    try:
        yield user_input.format(error=err)
    except KeyError:
        yield '\n\tKeyError: No global var named SECRET'


def greet_by_name_if_recognized(id):
    return f'Hello {names_for_ids.get(id, "anonymous")}'


if __name__ == '__main__':
    def iterate_generator(gen_reference):
        for _ in gen_reference():
            print('\t', _)

    map_methods = {
        1: first_method,
        2: second_method,
        3: third_method,
        4: fourth_method,
    }

    for method in map_methods.values():
        print(f'Format strings by {method.__name__}:')
        iterate_generator(method)
        print('\n')

    print(greet_by_name_if_recognized(814))
